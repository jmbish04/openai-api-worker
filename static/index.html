<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAI-Compatible API Worker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .badge {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .badge.streaming {
            background: #2196F3;
        }

        .badge.multimodal {
            background: #FF9800;
        }

        .badge.cors {
            background: #9C27B0;
        }

        .content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .nav {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            overflow-x: auto;
            flex-wrap: wrap;
        }

        .nav-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            border-radius: 8px 8px 0 0;
        }

        .nav-item:hover {
            background: #f5f5f5;
        }

        .nav-item.active {
            border-bottom-color: #667eea;
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .section h3 {
            color: #555;
            margin: 30px 0 15px 0;
            font-size: 1.3rem;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .copy-btn:hover {
            background: #5a67d8;
        }

        .api-tester {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            background: #5a67d8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #5a6268;
        }

        .response-area {
            margin-top: 20px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .alert.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .chat-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: white;
            margin: 20px 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
        }

        .message.user {
            background: #e3f2fd;
            margin-left: 20px;
        }

        .message.assistant {
            background: #f1f8e9;
            margin-right: 20px;
        }

        .message .role {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .message.user .role {
            color: #1976d2;
        }

        .message.assistant .role {
            color: #388e3c;
        }

        .endpoint-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .endpoint-card.active {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .endpoint-method {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .endpoint-method.post {
            background: #007bff;
        }

        .test-results {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .test-status {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            background: #6c757d;
        }

        .status-indicator.pass {
            background: #28a745;
        }

        .status-indicator.fail {
            background: #dc3545;
        }

        .status-indicator.pending {
            background: #ffc107;
        }

        .test-details {
            display: grid;
            gap: 15px;
        }

        .test-item {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            background: white;
        }

        .test-item.pass {
            border-color: #28a745;
            background: #d4edda;
        }

        .test-item.fail {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .test-item.pending {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .test-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .test-name {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .test-status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .test-status-badge.pass {
            background: #28a745;
            color: white;
        }

        .test-status-badge.fail {
            background: #dc3545;
            color: white;
        }

        .test-status-badge.pending {
            background: #ffc107;
            color: #212529;
        }

        .test-message {
            color: #6c757d;
            margin-bottom: 8px;
        }

        .test-stats {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
        }

        .test-stat {
            display: flex;
            align-items: center;
        }

        .test-stat-label {
            font-weight: 600;
            margin-right: 5px;
        }

        .test-stat-value {
            color: #007bff;
            font-weight: bold;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .status-indicator.disconnected {
            background: #dc3545;
        }

        .json-viewer {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .nav {
                flex-direction: column;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🚀 OpenAI API Worker</h1>
            <p>Cloudflare-powered AI with OpenAI compatibility</p>
            <div class="badges">
                <span class="badge">OpenAI Compatible</span>
                <span class="badge streaming">Streaming</span>
                <span class="badge multimodal">Multimodal</span>
                <span class="badge cors">CORS Ready</span>
            </div>
        </div>

        <div class="content">
            <div class="nav">
                <div class="nav-item active" onclick="showSection('overview')">📖 Overview</div>
                <div class="nav-item" onclick="showSection('tester')">🧪 API Tester</div>
                <div class="nav-item" onclick="showSection('chat')">💬 Chat Interface</div>
                <div class="nav-item" onclick="showSection('test')">🔍 API Tests</div>
                <div class="nav-item" onclick="showSection('endpoints')">🔗 Endpoints</div>
                <div class="nav-item" onclick="showSection('examples')">💡 Examples</div>
                <div class="nav-item" onclick="showSection('auth')">🔐 Authentication</div>
            </div>

            <div id="overview" class="section active">
                <h2>🌟 Welcome to OpenAI API Worker</h2>
                <p>This Cloudflare Worker provides a fully OpenAI-compatible API interface powered by Cloudflare's AI
                    models, OpenAI, and Google Gemini. Get the performance of edge computing with the familiarity of OpenAI's API.</p>

                <h3>✨ Key Features</h3>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>Multi-Provider Support:</strong> Cloudflare AI, OpenAI, and Google Gemini</li>
                    <li><strong>Structured Responses:</strong> JSON schema validation for reliable data extraction</li>
                    <li><strong>Memory System:</strong> KV-based conversation memory with keyword isolation</li>
                    <li><strong>Edge Performance:</strong> Powered by Cloudflare's global network</li>
                    <li><strong>Streaming Responses:</strong> Real-time response streaming</li>
                    <li><strong>Multiple Endpoints:</strong> Standard, structured, and text-only endpoints</li>
                    <li><strong>CORS Enabled:</strong> Ready for web applications</li>
                </ul>

                <h3>🚀 Quick Start</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code id="curl-example">curl -X POST [WORKER_URL]/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_WORKER_API_KEY" \
  -d '{
    "model": "gpt-4",
    "messages": [
      {"role": "user", "content": "Hello!"}
    ]
  }'
</code></pre>
                </div>

                <h3>📚 Resources</h3>
                <p>
                    • <a href="/openapi.json" target="_blank">OpenAPI Specification</a><br>
                    • <a href="/health" target="_blank">Health Check</a><br>
                    • <a href="https://docs.cloudflare.com/workers/">Cloudflare Workers Docs</a>
                </p>
            </div>

            <div id="tester" class="section">
                <h2>🧪 API Endpoint Tester</h2>
                <p>Test all API endpoints with your worker API key.</p>

                <div class="api-tester">
                    <h3>🔑 API Configuration</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="global-api-key">Worker API Key:</label>
                            <input type="password" id="global-api-key" placeholder="Enter your worker API key">
                        </div>
                        <div class="form-group">
                            <label>Connection Status:</label>
                            <div>
                                <span id="connection-status" class="status-indicator disconnected"></span>
                                <span id="connection-text">Not Connected</span>
                            </div>
                        </div>

                        <div class="form-group full-width">
                            <label for="ai-service">AI Service:</label>
                            <select id="ai-service" onchange="onAIServiceChange()">
                                <option value="">Choose AI Service...</option>
                                <option value="cloudflare">Cloudflare AI</option>
                                <option value="openai">OpenAI</option>
                                <option value="gemini">Google Gemini</option>
                            </select>
                        </div>

                        <div id="cloudflare-controls" class="form-group full-width" style="display:none">
                            <label for="cloudflare-provider-select">Cloudflare Provider:</label>
                            <select id="cloudflare-provider-select" onchange="onCloudflareProviderChange()">
                                <option value="">Choose provider...</option>
                            </select>
                        </div>

                        <div id="model-controls" class="form-group full-width" style="display:none">
                            <label for="model-select">Model:</label>
                            <select id="model-select">
                                <option value="">Choose model...</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn" onclick="testConnection()">Test Connection</button>
                    <button class="btn secondary" onclick="clearApiKey()">Clear Key</button>
                </div>

                <div class="api-tester">
                    <h3>📋 Available Endpoints</h3>

                    <div class="endpoint-card" onclick="selectEndpoint('models')">
                        <div class="endpoint-method">GET</div>
                        <h4>/v1/models</h4>
                        <p>List all available AI models</p>
                    </div>

                    <div class="endpoint-card" onclick="selectEndpoint('chat')">
                        <div class="endpoint-method post">POST</div>
                        <h4>/v1/chat/completions</h4>
                        <p>Create chat completions (streaming & non-streaming)</p>
                    </div>

                    <div class="endpoint-card" onclick="selectEndpoint('completions')">
                        <div class="endpoint-method post">POST</div>
                        <h4>/v1/completions</h4>
                        <p>Legacy text completion endpoint</p>
                    </div>
                </div>

                <div id="endpoint-tester" style="display: none;">
                    <div class="api-tester">
                        <h3 id="endpoint-title">Test Endpoint</h3>
                        <div id="endpoint-form"></div>
                        <div class="response-area" id="endpoint-response"></div>
                    </div>
                </div>
            </div>

            <div id="chat" class="section">
                <h2>💬 Interactive Chat Interface</h2>
                <p>Chat with the AI using your worker API key.</p>

                <div class="api-tester">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="chat-api-key">Worker API Key:</label>
                            <input type="password" id="chat-api-key" placeholder="Enter your worker API key"
                                onchange="onChatApiKeyChange()">
                        </div>
                        <div class="form-group">
                            <label for="chat-ai-service">AI Service:</label>
                            <select id="chat-ai-service" onchange="onChatAIServiceChange()">
                                <option value="">Choose AI Service...</option>
                                <option value="cloudflare">Cloudflare AI</option>
                                <option value="openai">OpenAI</option>
                                <option value="gemini">Google Gemini</option>
                            </select>
                        </div>
                    </div>

                    <div id="chat-cloudflare-controls" class="form-group full-width" style="display:none">
                        <label for="chat-cloudflare-provider">Cloudflare Provider:</label>
                        <select id="chat-cloudflare-provider" onchange="onChatCloudflareProviderChange()">
                            <option value="">Choose provider...</option>
                        </select>
                    </div>

                    <div class="form-group full-width">
                        <label for="chat-model">Model:</label>
                        <select id="chat-model">
                            <option value="">Choose model...</option>
                        </select>
                    </div>

                    <div class="chat-container" id="chat-messages">
                        <div class="message assistant">
                            <div class="role">Assistant</div>
                            <div>Hello! I'm ready to help. Enter your API key above and start chatting!</div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="chat-input">Your Message:</label>
                        <textarea id="chat-input" placeholder="Type your message here..."
                            onkeypress="handleChatKeyPress(event)"></textarea>
                    </div>

                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="btn" onclick="sendChatMessage()" id="send-btn">Send Message</button>
                        <label style="display: flex; align-items: center; gap: 5px; margin: 0;">
                            <input type="checkbox" id="stream-chat"> Enable Streaming
                        </label>
                        <button class="btn secondary" onclick="clearChat()">Clear Chat</button>
                    </div>
                </div>
            </div>

            <div id="test" class="section">
                <h2>🔍 API Connection Tests</h2>
                <p>Test the connectivity and functionality of all external API integrations.</p>

                <div class="api-tester">
                    <div class="form-group">
                        <button class="btn" onclick="runAPITests()">🔄 Run All Tests</button>
                        <button class="btn secondary" onclick="clearTestResults()">Clear Results</button>
                    </div>

                    <div id="test-results" class="test-results">
                        <div class="test-status">
                            <div class="status-indicator" id="test-status-indicator"></div>
                            <span id="test-status-text">Ready to test</span>
                        </div>
                        
                        <div id="test-details" class="test-details">
                            <!-- Test results will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <div id="endpoints" class="section">
                <h2>🔗 API Endpoints</h2>

                <h3>Public Endpoints (No Authentication)</h3>
                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/</h4>
                    <p>This interactive documentation page</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/openapi.json</h4>
                    <p>Complete OpenAPI 3.0 specification</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/health</h4>
                    <p>Service health status check</p>
                </div>

                <h3>API Endpoints (Require Authentication)</h3>
                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/chat/completions</h4>
                    <p>Create chat completions with optional memory support and response formatting</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/chat/completions/structured</h4>
                    <p>Create structured chat completions with JSON schema validation (requires response_format.schema)</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/chat/completions/text</h4>
                    <p>Create text-only chat completions without structured output (memory support available)</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/v1/models</h4>
                    <p>List all available models from all providers (Cloudflare AI, OpenAI, Google Gemini)</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/completions</h4>
                    <p>Legacy completion endpoint for simple text generation</p>
                </div>
            </div>

            <div id="examples" class="section">
                <h2>💡 Code Examples</h2>

                <h3>JavaScript / Node.js</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-javascript">const response = await fetch('[WORKER_URL]/v1/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_WORKER_API_KEY'
  },
  body: JSON.stringify({
    model: 'gpt-4',
    messages: [
      {
        role: 'user',
        content: 'Explain quantum computing'
      }
    ],
    max_tokens: 500,
    temperature: 0.7
  })
});

const data = await response.json();
console.log(data.choices[0].message.content);
</code></pre>
                </div>

                <h3>Python</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-python">import requests

response = requests.post(
    '[WORKER_URL]/v1/chat/completions',
    headers={
        'Content-Type': 'application/json',
        'Authorization': 'Bearer YOUR_WORKER_API_KEY'
    },
    json={
        'model': 'gpt-4',
        'messages': [
            {
                'role': 'user',
                'content': 'Explain quantum computing'
            }
        ],
        'max_tokens': 500,
        'temperature': 0.7
    }
)

print(response.json()['choices'][0]['message']['content'])
</code></pre>
                </div>

                <h3>cURL</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-shell">curl -X POST [WORKER_URL]/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_WORKER_API_KEY" \
  -d '{
    "model": "gpt-4",
    "messages": [
      {"role": "user", "content": "Hello!"}
    ],
    "max_tokens": 100
  }'
</code></pre>
                </div>
            </div>

            <div id="auth" class="section">
                <h2>🔐 Authentication</h2>

                <p>This API uses Bearer token authentication. Include your worker API key in the Authorization header:
                </p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    Authorization: Bearer YOUR_WORKER_API_KEY
                </div>

                <h3>Setting Up Your Worker API Key</h3>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>Choose a secure API key for your worker (e.g., <code>sk-myworker-abc123...</code>)</li>
                    <li>Store the key securely (never expose in client-side code)</li>
                    <li>Set it in production using <code>wrangler secret put WORKER_API_KEY</code></li>
                    <li>Users will include this key in all API requests to your worker</li>
                </ol>

                <div class="alert error">
                    <strong>⚠️ Security Warning:</strong> Never expose your worker API key in client-side JavaScript or
                    public repositories. Always use environment variables or secure key management systems.
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentEndpoint = null;
        let chatHistory = [];
        let availableModels = []; // full /v1/models response
        let cloudflareProviders = {}; // provider -> [models]
        let openaiModels = []; // OpenAI models
        let geminiModels = []; // Gemini models

        // Utility: escape HTML for safe insertion
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/[&"'<>]/g, function (s) {
                return ({
                    '&': '&amp;', '"': '&quot;', "'": '&#39;',
                    '<': '&lt;', '>': '&gt;'
                })[s];
            });
        }

        // Show / hide main sections
        function showSection(id) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            const el = document.getElementById(id);
            if (el) el.classList.add('active');
            // update nav active state
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => { if (n.getAttribute('onclick') && n.getAttribute('onclick').includes(id)) n.classList.add('active'); });
            // Update URL hash
            location.hash = id;
        }

        // Copy button for code samples
        function copyToClipboard(btn) {
            try {
                const codeEl = btn.parentElement.querySelector('code');
                const text = codeEl ? codeEl.textContent : '';
                navigator.clipboard.writeText(text).then(() => {
                    const old = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = old, 1200);
                });
            } catch (e) {
                console.error('Copy failed', e);
            }
        }

        // on DOM ready
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                const currentOrigin = location.origin;

                // Replace placeholders inside code samples
                document.querySelectorAll('.code-block code').forEach(codeEl => {
                    codeEl.textContent = codeEl.textContent.replace(/\[WORKER_URL\]/g, currentOrigin);
                });

                // Wire initial UI events
                document.getElementById('ai-service').addEventListener('change', onAIServiceChange);
                document.getElementById('cloudflare-provider-select').addEventListener('change', onCloudflareProviderChange);
                document.getElementById('chat-ai-service').addEventListener('change', onChatAIServiceChange);
                document.getElementById('chat-cloudflare-provider').addEventListener('change', onChatCloudflareProviderChange);
                document.getElementById('global-api-key').addEventListener('change', () => testConnection());
                document.getElementById('chat-api-key').addEventListener('change', onChatApiKeyChange);

                // Handle API key from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const apiKeyFromUrl = urlParams.get('apiKey');
                if (apiKeyFromUrl) {
                    document.getElementById('global-api-key').value = apiKeyFromUrl;
                    document.getElementById('chat-api-key').value = apiKeyFromUrl;
                    await testConnection(); // Automatically test connection
                }

                // Handle hash routing
                window.addEventListener('hashchange', handleHashChange);
                handleHashChange(); // Handle initial hash

                onAIServiceChange();
            } catch (error) {
                console.log('Initialization error:', error);
            }
        });

        // Handle URL hash changes for navigation
        function handleHashChange() {
            const hash = location.hash.substring(1);
            if (hash) {
                showSection(hash);
            } else {
                showSection('overview'); // Default section
            }
        }

        // Load and categorize models from /v1/models using an API key
        async function loadAndCategorizeModels(apiKey) {
            if (!apiKey) return;
            try {
                const res = await fetch('/v1/models', {
                    headers: { 'Authorization': 'Bearer ' + apiKey }
                });

                if (!res.ok) {
                    console.warn('/v1/models returned', res.status);
                    throw new Error('Failed to fetch models: ' + res.status);
                }

                const data = await res.json();
                availableModels = data.data || data.models || [];

                // Reset and categorize
                cloudflareProviders = {};
                const openaiList = [];
                const geminiList = [];

                availableModels.forEach(m => {
                    const id = (m.id || m.name || '').toLowerCase();
                    const owner = (m.owner || '').toLowerCase();

                    // Cloudflare provider categorization
                    let providerMatch = null;
                    if (id.startsWith('@cf/')) {
                        const parts = id.substring(4).split('/');
                        if (parts.length > 1) {
                            providerMatch = parts[0];
                        }
                    }

                    if (providerMatch) {
                        if (!cloudflareProviders[providerMatch]) {
                            cloudflareProviders[providerMatch] = [];
                        }
                        cloudflareProviders[providerMatch].push(m);
                    }

                    // OpenAI/Gemini categorization - prioritize specific patterns
                    if (id.includes('gemini') || owner.includes('google')) {
                        geminiList.push(m);
                    } else if ((id.includes('gpt') || owner.includes('openai') || id.startsWith('text-') || id.startsWith('oai-')) && !id.startsWith('@cf/') && !id.startsWith('@hf/')) {
                        openaiList.push(m);
                    } else if (!providerMatch && !id.startsWith('@cf/') && !id.startsWith('@hf/')) {
                        // Only add to openaiList if it's not a Cloudflare or HuggingFace model
                        openaiList.push(m);
                    }
                });

                // Populate cloudflare provider selects (both main and chat)
                const providerSelect = document.getElementById('cloudflare-provider-select');
                const chatProviderSelect = document.getElementById('chat-cloudflare-provider');
                
                [providerSelect, chatProviderSelect].forEach(select => {
                    select.innerHTML = '';
                    const noneOption = document.createElement('option');
                    noneOption.value = '';
                    noneOption.textContent = 'Choose provider...';
                    select.appendChild(noneOption);
                    Object.keys(cloudflareProviders).sort().forEach(p => {
                        const o = document.createElement('option');
                        o.value = p;
                        o.textContent = `${p} (${cloudflareProviders[p].length} models)`;
                        select.appendChild(o);
                    });
                });
                
                if (!providerSelect.value && providerSelect.options.length > 1) providerSelect.selectedIndex = 1;
                onCloudflareProviderChange();

                // Store categorized models for use in dropdowns
                openaiModels = openaiList;
                geminiModels = geminiList;

                // Update all model selectors
                updateModelSelectors();
                updateChatModelSelectors();

            } catch (err) {
                console.error('Error loading models:', err);
                // re-throw to be caught by caller
                throw err;
            }
        }

        // When user picks a cloudflare provider, populate provider-specific models
        function onCloudflareProviderChange() {
            const provider = document.getElementById('cloudflare-provider-select').value;
            updateModelSelectors();
        }

        // Chat-specific cloudflare provider change handler
        function onChatCloudflareProviderChange() {
            updateChatModelSelectors();
        }

        // When AI service changes, show/hide controls and update model selector
        function onAIServiceChange() {
            const svc = document.getElementById('ai-service').value;
            const cloudflareControls = document.getElementById('cloudflare-controls');
            const modelControls = document.getElementById('model-controls');
            
            // Show/hide Cloudflare provider dropdown
            if (svc === 'cloudflare') {
                cloudflareControls.style.display = 'block';
                modelControls.style.display = 'block';
            } else {
                cloudflareControls.style.display = 'none';
                modelControls.style.display = svc ? 'block' : 'none';
            }

            // Clear and populate models based on service
            updateModelSelectors();
        }

        // Chat-specific AI service change handler
        function onChatAIServiceChange() {
            const svc = document.getElementById('chat-ai-service').value;
            const cloudflareControls = document.getElementById('chat-cloudflare-controls');
            
            // Show/hide Cloudflare provider dropdown
            if (svc === 'cloudflare') {
                cloudflareControls.style.display = 'block';
            } else {
                cloudflareControls.style.display = 'none';
            }

            // Update chat model selector
            updateChatModelSelectors();
        }

        // Update model selectors for the main tester
        function updateModelSelectors() {
            const svc = document.getElementById('ai-service').value;
            const modelSelect = document.getElementById('model-select');
            modelSelect.innerHTML = '<option value="">Choose model...</option>';

            if (svc === 'cloudflare') {
                const provider = document.getElementById('cloudflare-provider-select').value;
                if (provider && cloudflareProviders[provider]) {
                    cloudflareProviders[provider].forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id || model.name;
                        option.textContent = (model.id || model.name) + (model.description ? ` - ${model.description.substring(0, 50)}...` : '');
                        modelSelect.appendChild(option);
                    });
                }
            } else if (svc === 'openai') {
                openaiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id || model.name;
                    option.textContent = model.id || model.name;
                    modelSelect.appendChild(option);
                });
            } else if (svc === 'gemini') {
                geminiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id || model.name;
                    option.textContent = model.id || model.name;
                    modelSelect.appendChild(option);
                });
            }
        }

        // Update chat model selectors
        function updateChatModelSelectors() {
            const svc = document.getElementById('chat-ai-service').value;
            const chatModelSelect = document.getElementById('chat-model');
            chatModelSelect.innerHTML = '<option value="">Choose model...</option>';

            if (svc === 'cloudflare') {
                const provider = document.getElementById('chat-cloudflare-provider').value;
                if (provider && cloudflareProviders[provider]) {
                    cloudflareProviders[provider].forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id || model.name;
                        option.textContent = (model.id || model.name) + (model.description ? ` - ${model.description.substring(0, 50)}...` : '');
                        chatModelSelect.appendChild(option);
                    });
                }
            } else if (svc === 'openai') {
                openaiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id || model.name;
                    option.textContent = model.id || model.name;
                    chatModelSelect.appendChild(option);
                });
            } else if (svc === 'gemini') {
                geminiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id || model.name;
                    option.textContent = model.id || model.name;
                    chatModelSelect.appendChild(option);
                });
            }
        }

        // Test connection button: attempt to call /v1/models with provided key
        async function testConnection() {
            const key = document.getElementById('global-api-key').value;
            const statusIndicator = document.getElementById('connection-status');
            const statusText = document.getElementById('connection-text');

            if (!key) {
                alert('Enter your API key first');
                return;
            }

            try {
                // Indicate loading
                statusText.textContent = 'Connecting...';
                await loadAndCategorizeModels(key);

                // If successful, update status
                statusIndicator.classList.remove('disconnected');
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';

            } catch (err) {
                console.error('Connection test error', err);
                statusIndicator.classList.remove('connected');
                statusIndicator.classList.add('disconnected');
                statusText.textContent = 'Connection Failed';
                // alert('Connection test failed: ' + err.message);
            }
        }

        function clearApiKey() {
            document.getElementById('global-api-key').value = '';
            document.getElementById('connection-text').textContent = 'Not Connected';
            document.getElementById('connection-status').classList.remove('connected');
            document.getElementById('connection-status').classList.add('disconnected');
        }

        async function onChatApiKeyChange() {
            const key = document.getElementById('chat-api-key').value;
            if (key) {
                // also update global key for consistency
                document.getElementById('global-api-key').value = key;
                await testConnection();
            }
        }

        function handleChatKeyPress(e) {
            if ((e.key === 'Enter' && !e.shiftKey)) {
                e.preventDefault();
                sendChatMessage();
            }
        }

        function clearChat() {
            chatHistory = [];
            const container = document.getElementById('chat-messages');
            container.innerHTML = '';
        }

        // Robust streaming-aware chat sender
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const userText = input.value.trim();
            if (!userText) return;

            const chatKey = document.getElementById('chat-api-key').value || document.getElementById('global-api-key').value;
            const aiService = document.getElementById('chat-ai-service').value;
            const streamEnabled = document.getElementById('stream-chat').checked;

            // Get selected model
            let model = document.getElementById('chat-model').value;

            // Append user message to UI
            const container = document.getElementById('chat-messages');
            const userMsg = document.createElement('div');
            userMsg.className = 'message user';
            userMsg.innerHTML = '<div class="role">User</div><div>' + escapeHtml(userText) + '</div>';
            container.appendChild(userMsg);
            container.scrollTop = container.scrollHeight;
            input.value = '';

            // Prepare request body for chat completions (OpenAI-style)
            const body = {
                model: model,
                messages: [
                    ...chatHistory,
                    { role: 'user', content: userText }
                ],
                stream: streamEnabled
            };

            const headers = { 'Content-Type': 'application/json' };
            if (chatKey) headers['Authorization'] = 'Bearer ' + chatKey;

            try {
                const res = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(body)
                });

                if (!res.ok) {
                    const errText = await res.text();
                    const errEl = document.createElement('div');
                    errEl.className = 'alert error';
                    errEl.textContent = 'Error: ' + res.status + ' - ' + errText;
                    container.appendChild(errEl);
                    container.scrollTop = container.scrollHeight;
                    return;
                }

                if (streamEnabled && res.body) {
                    // Create assistant message block that we will stream into
                    const assistantMsg = document.createElement('div');
                    assistantMsg.className = 'message assistant';
                    assistantMsg.innerHTML = '<div class="role">Assistant</div><div class="streaming-content"></div>';
                    container.appendChild(assistantMsg);
                    container.scrollTop = container.scrollHeight;

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let finalText = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });

                        // Split on newlines to handle 'data: {...}' chunks
                        const lines = buffer.split(/\n/);
                        // Keep last partial line in buffer
                        buffer = lines.pop() || '';

                        for (let line of lines) {
                            line = line.trim();
                            if (!line) continue;
                            // common SSE style: 'data: {...}' or 'data: [DONE]'
                            if (line.startsWith('data:')) {
                                const payload = line.replace(/^data:\s*/, '');
                                if (payload === '[DONE]') {
                                    // stream finished
                                    buffer = '';
                                    break;
                                }
                                try {
                                    const parsed = JSON.parse(payload);
                                    const delta = (parsed.choices && parsed.choices[0]) || parsed;
                                    // Try several possible fields for content
                                    const part = (delta.delta && delta.delta.content) || (delta.delta && delta.delta.text) || delta.text || (delta.message && delta.message.content) || delta.choices?.[0]?.text;
                                    if (part) {
                                        finalText += part;
                                        assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                        container.scrollTop = container.scrollHeight;
                                    }
                                } catch (e) {
                                    // not JSON, append raw
                                    finalText += payload + '\n';
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                }
                            } else {
                                // fallback: treat line as raw JSON or plain text
                                try {
                                    const parsed = JSON.parse(line);
                                    const text = parsed.choices?.[0]?.delta?.content || parsed.choices?.[0]?.text || parsed.message?.content || '';
                                    finalText += text;
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                } catch (e) {
                                    finalText += line + '\n';
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                }
                            }
                        }
                    }

                    // Finalize message
                    chatHistory.push({ role: 'user', content: userText });
                    chatHistory.push({ role: 'assistant', content: finalText });
                } else {
                    // Non-streaming response: parse JSON normally
                    const json = await res.json();
                    const text = extractTextFromResponseObject(json);
                    const assistantMsg = document.createElement('div');
                    assistantMsg.className = 'message assistant';
                    assistantMsg.innerHTML = '<div class="role">Assistant</div><div>' + escapeHtml(text) + '</div>';
                    container.appendChild(assistantMsg);
                    container.scrollTop = container.scrollHeight;

                    chatHistory.push({ role: 'user', content: userText });
                    chatHistory.push({ role: 'assistant', content: text });
                }
            } catch (err) {
                console.error('Chat request failed', err);
                const errEl = document.createElement('div');
                errEl.className = 'alert error';
                errEl.textContent = 'Request failed: ' + err.message;
                container.appendChild(errEl);
                container.scrollTop = container.scrollHeight;
            }
        }

        // Try to extract assistant text from typical OpenAI/Gemini /v1/chat/completions JSON
        function extractTextFromResponseObject(obj) {
            try {
                if (!obj) return '';
                if (obj.choices && obj.choices[0]) {
                    const choice = obj.choices[0];
                    if (choice.message && choice.message.content) return choice.message.content;
                    if (choice.text) return choice.text;
                    if (choice.delta && (choice.delta.content || choice.delta.text)) return choice.delta.content || choice.delta.text;
                }
                if (obj.output && Array.isArray(obj.output)) {
                    // Gemini-style
                    return obj.output.map(o => o.content?.map(c => c.text).join('') || '').join('\n');
                }
                return JSON.stringify(obj);
            } catch (e) {
                return '';
            }
        }

        // Endpoint selector for tester panel (existing UI hook)
        function selectEndpoint(name) {
            currentEndpoint = name;
            const holder = document.getElementById('endpoint-form');
            const responseArea = document.getElementById('endpoint-response');
            document.getElementById('endpoint-title').textContent = 'Test: ' + name;
            responseArea.innerHTML = '';
            holder.innerHTML = '';

            if (name === 'models') {
                holder.innerHTML = '<div class="form-group full-width"><label>API Key (optional)</label><input id="test-models-key" placeholder="Bearer key for provider-specific models"></div><button class="btn" onclick="runTestModels()">Run</button>';
            } else if (name === 'chat') {
                holder.innerHTML = '<div class="form-group"><label>API Key (optional)</label><input id="test-chat-key" placeholder="Bearer key"></div><div class="form-group full-width"><label>Model</label><input id="test-chat-model" placeholder="gpt-4"></div><div class="form-group full-width"><label>Messages (JSON array)</label><textarea id="test-chat-messages">[ { "role": "user", "content": "Hello" } ]</textarea></div><button class="btn" onclick="runTestChat()">Run</button>';
            } else if (name === 'completions') {
                holder.innerHTML = '<div class="form-group"><label>API Key (optional)</label><input id="test-comp-key" placeholder="Bearer key"></div><div class="form-group full-width"><label>Model</label><input id="test-comp-model" placeholder="gpt-4"></div><div class="form-group full-width"><label>Prompt</label><textarea id="test-comp-prompt">Hello</textarea></div><button class="btn" onclick="runTestCompletions()">Run</button>';
            }
            document.getElementById('endpoint-tester').style.display = 'block';
        }

        async function runTestModels() {
            const key = document.getElementById('test-models-key').value;
            const headers = key ? { 'Authorization': 'Bearer ' + key } : {};
            const res = await fetch('/v1/models', { headers });
            const text = await res.text();
            document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
        }

        async function runTestChat() {
            try {
                const key = document.getElementById('test-chat-key').value;
                const model = document.getElementById('test-chat-model').value || 'gpt-4';
                const messages = JSON.parse(document.getElementById('test-chat-messages').value || '[]');
                const headers = { 'Content-Type': 'application/json' };
                if (key) headers['Authorization'] = 'Bearer ' + key;
                const res = await fetch('/v1/chat/completions', { method: 'POST', headers, body: JSON.stringify({ model, messages }) });
                const text = await res.text();
                document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
            } catch (e) {
                document.getElementById('endpoint-response').innerHTML = '<div class="alert error">' + escapeHtml(e.message) + '</div>';
            }
        }

        async function runTestCompletions() {
            try {
                const key = document.getElementById('test-comp-key').value;
                const model = document.getElementById('test-comp-model').value || 'gpt-4';
                const prompt = document.getElementById('test-comp-prompt').value || '';
                const headers = { 'Content-Type': 'application/json' };
                if (key) headers['Authorization'] = 'Bearer ' + key;
                const res = await fetch('/v1/completions', { method: 'POST', headers, body: JSON.stringify({ model, prompt }) });
                const text = await res.text();
                document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
            } catch (e) {
                document.getElementById('endpoint-response').innerHTML = '<div class="alert error">' + escapeHtml(e.message) + '</div>';
            }
        }

        // Test functions
        async function runAPITests() {
            const statusIndicator = document.getElementById('test-status-indicator');
            const statusText = document.getElementById('test-status-text');
            const testDetails = document.getElementById('test-details');
            
            // Set loading state
            statusIndicator.className = 'status-indicator pending';
            statusText.textContent = 'Running tests...';
            testDetails.innerHTML = '<div class="test-item pending"><div class="test-message">Loading test results...</div></div>';
            
            try {
                const response = await fetch('/test/apis', {
                    headers: {
                        'Authorization': 'Bearer ' + document.getElementById('global-api-key').value
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                displayTestResults(data);
                
            } catch (error) {
                console.error('Test error:', error);
                statusIndicator.className = 'status-indicator fail';
                statusText.textContent = 'Test failed';
                testDetails.innerHTML = `<div class="test-item fail"><div class="test-message">Error: ${error.message}</div></div>`;
            }
        }
        
        function displayTestResults(data) {
            const statusIndicator = document.getElementById('test-status-indicator');
            const statusText = document.getElementById('test-status-text');
            const testDetails = document.getElementById('test-details');
            
            // Determine overall status
            const allPassed = Object.values(data.tests).every(test => test.status === 'PASS');
            const anyFailed = Object.values(data.tests).some(test => test.status === 'FAIL');
            
            if (allPassed) {
                statusIndicator.className = 'status-indicator pass';
                statusText.textContent = 'All tests passed';
            } else if (anyFailed) {
                statusIndicator.className = 'status-indicator fail';
                statusText.textContent = 'Some tests failed';
            } else {
                statusIndicator.className = 'status-indicator pending';
                statusText.textContent = 'Tests completed';
            }
            
            // Display individual test results
            testDetails.innerHTML = Object.entries(data.tests).map(([name, test]) => {
                const testName = name.charAt(0).toUpperCase() + name.slice(1).replace(/([A-Z])/g, ' $1');
                return `
                    <div class="test-item ${test.status.toLowerCase()}">
                        <div class="test-header">
                            <div class="test-name">${testName}</div>
                            <div class="test-status-badge ${test.status.toLowerCase()}">${test.status}</div>
                        </div>
                        <div class="test-message">${test.message}</div>
                        <div class="test-stats">
                            <div class="test-stat">
                                <span class="test-stat-label">Models:</span>
                                <span class="test-stat-value">${test.models}</span>
                            </div>
                            ${test.providers ? `
                                <div class="test-stat">
                                    <span class="test-stat-label">Providers:</span>
                                    <span class="test-stat-value">${test.providers}</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function clearTestResults() {
            const statusIndicator = document.getElementById('test-status-indicator');
            const statusText = document.getElementById('test-status-text');
            const testDetails = document.getElementById('test-details');
            
            statusIndicator.className = 'status-indicator';
            statusText.textContent = 'Ready to test';
            testDetails.innerHTML = '';
        }

        // expose a couple helpers to global scope for inline onclick usage
        window.selectEndpoint = selectEndpoint;
        window.copyToClipboard = copyToClipboard;
        window.testConnection = testConnection;
        window.clearApiKey = clearApiKey;
        window.runTestModels = runTestModels;
        window.runTestChat = runTestChat;
        window.runTestCompletions = runTestCompletions;
        window.sendChatMessage = sendChatMessage;
        window.showSection = showSection;
        window.clearChat = clearChat;
        window.runAPITests = runAPITests;
        window.clearTestResults = clearTestResults;
    </script>
</body>

</html>
