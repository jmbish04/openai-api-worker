<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAI-Compatible API Worker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .badge {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .badge.streaming {
            background: #2196F3;
        }

        .badge.multimodal {
            background: #FF9800;
        }

        .badge.cors {
            background: #9C27B0;
        }

        .content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .nav {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            overflow-x: auto;
            flex-wrap: wrap;
        }

        .nav-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            border-radius: 8px 8px 0 0;
        }

        .nav-item:hover {
            background: #f5f5f5;
        }

        .nav-item.active {
            border-bottom-color: #667eea;
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .section h3 {
            color: #555;
            margin: 30px 0 15px 0;
            font-size: 1.3rem;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            position: relative;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .copy-btn:hover {
            background: #5a67d8;
        }

        .api-tester {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            background: #5a67d8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #5a6268;
        }

        .response-area {
            margin-top: 20px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .alert.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .chat-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: white;
            margin: 20px 0;
        }

        .message {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
        }

        .message.user {
            background: #e3f2fd;
            margin-left: 20px;
        }

        .message.assistant {
            background: #f1f8e9;
            margin-right: 20px;
        }

        .message .role {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .message.user .role {
            color: #1976d2;
        }

        .message.assistant .role {
            color: #388e3c;
        }

        .endpoint-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .endpoint-card.active {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .endpoint-method {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .endpoint-method.post {
            background: #007bff;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .status-indicator.disconnected {
            background: #dc3545;
        }

        .json-viewer {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .nav {
                flex-direction: column;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ OpenAI API Worker</h1>
            <p>Cloudflare-powered AI with OpenAI compatibility</p>
            <div class="badges">
                <span class="badge">OpenAI Compatible</span>
                <span class="badge streaming">Streaming</span>
                <span class="badge multimodal">Multimodal</span>
                <span class="badge cors">CORS Ready</span>
            </div>
        </div>

        <div class="content">
            <div class="nav">
                <div class="nav-item active" onclick="showSection('overview')">üìñ Overview</div>
                <div class="nav-item" onclick="showSection('tester')">üß™ API Tester</div>
                <div class="nav-item" onclick="showSection('chat')">üí¨ Chat Interface</div>
                <div class="nav-item" onclick="showSection('endpoints')">üîó Endpoints</div>
                <div class="nav-item" onclick="showSection('examples')">üí° Examples</div>
                <div class="nav-item" onclick="showSection('auth')">üîê Authentication</div>
            </div>

            <div id="overview" class="section active">
                <h2>üåü Welcome to OpenAI API Worker</h2>
                <p>This Cloudflare Worker provides a fully OpenAI-compatible API interface powered by Cloudflare's AI
                    models. Get the performance of edge computing with the familiarity of OpenAI's API.</p>

                <h3>‚ú® Key Features</h3>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>OpenAI Compatible:</strong> Drop-in replacement for OpenAI API</li>
                    <li><strong>Edge Performance:</strong> Powered by Cloudflare's global network</li>
                    <li><strong>Multimodal Support:</strong> Text generation and image recognition</li>
                    <li><strong>Streaming Responses:</strong> Real-time response streaming</li>
                    <li><strong>Multiple Models:</strong> Primary and backup model support</li>
                    <li><strong>CORS Enabled:</strong> Ready for web applications</li>
                </ul>

                <h3>üöÄ Quick Start</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code id="curl-example">curl -X POST [WORKER_URL]/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_WORKER_API_KEY" \
  -d '{
    "model": "gpt-4",
    "messages": [
      {"role": "user", "content": "Hello!"}
    ]
  }'
</code></pre>
                </div>

                <h3>üìö Resources</h3>
                <p>
                    ‚Ä¢ <a href="/openapi.json" target="_blank">OpenAPI Specification</a><br>
                    ‚Ä¢ <a href="/health" target="_blank">Health Check</a><br>
                    ‚Ä¢ <a href="https://docs.cloudflare.com/workers/">Cloudflare Workers Docs</a>
                </p>
            </div>

            <div id="tester" class="section">
                <h2>üß™ API Endpoint Tester</h2>
                <p>Test all API endpoints with your worker API key.</p>

                <div class="api-tester">
                    <h3>üîë API Configuration</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="global-api-key">Worker API Key:</label>
                            <input type="password" id="global-api-key" placeholder="Enter your worker API key">
                        </div>
                        <div class="form-group">
                            <label>Connection Status:</label>
                            <div>
                                <span id="connection-status" class="status-indicator disconnected"></span>
                                <span id="connection-text">Not Connected</span>
                            </div>
                        </div>

                        <div class="form-group full-width">
                            <label for="ai-service">AI Service:</label>
                            <select id="ai-service" onchange="onAIServiceChange()">
                                <option value="cloudflare">Cloudflare (edge)</option>
                                <option value="openai">OpenAI</option>
                                <option value="gemini">Gemini</option>
                            </select>
                        </div>

                        <div id="openai-controls" class="form-group" style="display:none">
                            <label for="openai-model-select">OpenAI Model:</label>
                            <select id="openai-model-select"></select>
                        </div>

                        <div id="gemini-controls" class="form-group" style="display:none">
                            <label for="gemini-model-select">Gemini Model:</label>
                            <select id="gemini-model-select"></select>
                        </div>

                        <div id="cloudflare-controls" class="form-group full-width">
                            <label for="cloudflare-provider-select">Cloudflare Provider:</label>
                            <select id="cloudflare-provider-select" onchange="onCloudflareProviderChange()"></select>
                        </div>

                        <div id="cloudflare-model-controls" class="form-group full-width">
                            <label for="cloudflare-model-select">Cloudflare Model:</label>
                            <select id="cloudflare-model-select"></select>
                        </div>
                    </div>
                    <button class="btn" onclick="testConnection()">Test Connection</button>
                    <button class="btn secondary" onclick="clearApiKey()">Clear Key</button>
                </div>

                <div class="api-tester">
                    <h3>üìã Available Endpoints</h3>

                    <div class="endpoint-card" onclick="selectEndpoint('models')">
                        <div class="endpoint-method">GET</div>
                        <h4>/v1/models</h4>
                        <p>List all available AI models</p>
                    </div>

                    <div class="endpoint-card" onclick="selectEndpoint('chat')">
                        <div class="endpoint-method post">POST</div>
                        <h4>/v1/chat/completions</h4>
                        <p>Create chat completions (streaming & non-streaming)</p>
                    </div>

                    <div class="endpoint-card" onclick="selectEndpoint('completions')">
                        <div class="endpoint-method post">POST</div>
                        <h4>/v1/completions</h4>
                        <p>Legacy text completion endpoint</p>
                    </div>
                </div>

                <div id="endpoint-tester" style="display: none;">
                    <div class="api-tester">
                        <h3 id="endpoint-title">Test Endpoint</h3>
                        <div id="endpoint-form"></div>
                        <div class="response-area" id="endpoint-response"></div>
                    </div>
                </div>
            </div>

            <div id="chat" class="section">
                <h2>üí¨ Interactive Chat Interface</h2>
                <p>Chat with the AI using your worker API key.</p>

                <div class="api-tester">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="chat-api-key">Worker API Key:</label>
                            <input type="password" id="chat-api-key" placeholder="Enter your worker API key"
                                onchange="onChatApiKeyChange()">
                        </div>
                        <div class="form-group">
                            <label for="chat-model">Model:</label>
                            <select id="chat-model">
                                <option value="gpt-4">GPT-4 (Recommended)</option>
                                <option value="gpt-4-turbo">GPT-4 Turbo</option>
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                <option value="gpt-4o">GPT-4o</option>
                                <option value="gpt-4o-mini">GPT-4o Mini</option>
                            </select>
                        </div>
                    </div>

                    <div class="chat-container" id="chat-messages">
                        <div class="message assistant">
                            <div class="role">Assistant</div>
                            <div>Hello! I'm ready to help. Enter your API key above and start chatting!</div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="chat-input">Your Message:</label>
                        <textarea id="chat-input" placeholder="Type your message here..."
                            onkeypress="handleChatKeyPress(event)"></textarea>
                    </div>

                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="btn" onclick="sendChatMessage()" id="send-btn">Send Message</button>
                        <label style="display: flex; align-items: center; gap: 5px; margin: 0;">
                            <input type="checkbox" id="stream-chat"> Enable Streaming
                        </label>
                        <button class="btn secondary" onclick="clearChat()">Clear Chat</button>
                    </div>
                </div>
            </div>

            <div id="endpoints" class="section">
                <h2>üîó API Endpoints</h2>

                <h3>Public Endpoints (No Authentication)</h3>
                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/</h4>
                    <p>This interactive documentation page</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/openapi.json</h4>
                    <p>Complete OpenAPI 3.0 specification</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/health</h4>
                    <p>Service health status check</p>
                </div>

                <h3>API Endpoints (Require Authentication)</h3>
                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/chat/completions</h4>
                    <p>Create chat completions with support for streaming and multimodal inputs</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method">GET</div>
                    <h4>/v1/models</h4>
                    <p>List all available models and their capabilities</p>
                </div>

                <div class="endpoint-card">
                    <div class="endpoint-method post">POST</div>
                    <h4>/v1/completions</h4>
                    <p>Legacy completion endpoint for simple text generation</p>
                </div>
            </div>

            <div id="examples" class="section">
                <h2>üí° Code Examples</h2>

                <h3>JavaScript / Node.js</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-javascript">const response = await fetch('[WORKER_URL]/v1/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_WORKER_API_KEY'
  },
  body: JSON.stringify({
    model: 'gpt-4',
    messages: [
      {
        role: 'user',
        content: 'Explain quantum computing'
      }
    ],
    max_tokens: 500,
    temperature: 0.7
  })
});

const data = await response.json();
console.log(data.choices[0].message.content);
</code></pre>
                </div>

                <h3>Python</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-python">import requests

response = requests.post(
    '[WORKER_URL]/v1/chat/completions',
    headers={
        'Content-Type': 'application/json',
        'Authorization': 'Bearer YOUR_WORKER_API_KEY'
    },
    json={
        'model': 'gpt-4',
        'messages': [
            {
                'role': 'user',
                'content': 'Explain quantum computing'
            }
        ],
        'max_tokens': 500,
        'temperature': 0.7
    }
)

print(response.json()['choices'][0]['message']['content'])
</code></pre>
                </div>

                <h3>cURL</h3>
                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    <pre><code class="language-shell">curl -X POST [WORKER_URL]/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_WORKER_API_KEY" \
  -d '{
    "model": "gpt-4",
    "messages": [
      {"role": "user", "content": "Hello!"}
    ],
    "max_tokens": 100
  }'
</code></pre>
                </div>
            </div>

            <div id="auth" class="section">
                <h2>üîê Authentication</h2>

                <p>This API uses Bearer token authentication. Include your worker API key in the Authorization header:
                </p>

                <div class="code-block">
                    <button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>
                    Authorization: Bearer YOUR_WORKER_API_KEY
                </div>

                <h3>Setting Up Your Worker API Key</h3>
                <ol style="margin-left: 20px; margin-top: 10px;">
                    <li>Choose a secure API key for your worker (e.g., <code>sk-myworker-abc123...</code>)</li>
                    <li>Store the key securely (never expose in client-side code)</li>
                    <li>Set it in production using <code>wrangler secret put WORKER_API_KEY</code></li>
                    <li>Users will include this key in all API requests to your worker</li>
                </ol>

                <div class="alert error">
                    <strong>‚ö†Ô∏è Security Warning:</strong> Never expose your worker API key in client-side JavaScript or
                    public repositories. Always use environment variables or secure key management systems.
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentEndpoint = null;
        let chatHistory = [];
        let availableModels = []; // full /v1/models response
        let cloudflareProviders = {}; // provider -> [models]

        // Utility: escape HTML for safe insertion
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/[&"'<>]/g, function (s) {
                return ({
                    '&': '&amp;', '"': '&quot;', "'": '&#39;',
                    '<': '&lt;', '>': '&gt;'
                })[s];
            });
        }

        // Show / hide main sections
        function showSection(id) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            const el = document.getElementById(id);
            if (el) el.classList.add('active');
            // update nav active state
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => { if (n.getAttribute('onclick') && n.getAttribute('onclick').includes(id)) n.classList.add('active'); });
        }

        // Copy button for code samples
        function copyToClipboard(btn) {
            try {
                const codeEl = btn.parentElement.querySelector('code');
                const text = codeEl ? codeEl.textContent : '';
                navigator.clipboard.writeText(text).then(() => {
                    const old = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = old, 1200);
                });
            } catch (e) {
                console.error('Copy failed', e);
            }
        }

        // on DOM ready
        document.addEventListener('DOMContentLoaded', async function () {
            try {
                const currentOrigin = location.origin;

                // Replace placeholders inside code samples
                document.querySelectorAll('.code-block code').forEach(codeEl => {
                    codeEl.textContent = codeEl.textContent.replace(/\[WORKER_URL\]/g, currentOrigin);
                });

                // Wire initial UI events
                document.getElementById('ai-service').addEventListener('change', onAIServiceChange);
                document.getElementById('cloudflare-provider-select').addEventListener('change', onCloudflareProviderChange);
                document.getElementById('global-api-key').addEventListener('change', async () => await loadModelsWithAuth(document.getElementById('global-api-key').value));
                document.getElementById('chat-api-key').addEventListener('change', onChatApiKeyChange);

                // Chat key: update model selectors when changed
                await loadAvailableModels();
                onAIServiceChange();
            } catch (error) {
                console.log('Initialization error:', error);
            }
        });

        // Load models without auth (public /v1/models) to populate Cloudflare providers
        async function loadAvailableModels() {
            try {
                const res = await fetch('/v1/models');
                if (!res.ok) {
                    console.warn('/v1/models returned', res.status);
                    return;
                }
                const data = await res.json();
                availableModels = data.data || data.models || [];

                // Derive Cloudflare providers heuristically from model ids
                cloudflareProviders = {};
                availableModels.forEach(m => {
                    const id = m.id || m.name || '';
                    // look for patterns like '@cf/<provider>/' or '@cf/<provider>' or '/cf-<provider>/'
                    let providerMatch = null;
                    if (id.includes('@cf/')) {
                        const parts = id.split('@cf/')[1].split('/');
                        providerMatch = parts[0];
                    } else if (/@cf:/.test(id)) {
                        providerMatch = id.split('@cf:')[1].split('/')[0];
                    } else if (id.includes('/@cf/')) {
                        providerMatch = id.split('/@cf/')[1].split('/')[0];
                    }

                    if (providerMatch) {
                        cloudflareProviders[providerMatch] = cloudflareProviders[providerMatch] || [];
                        cloudflareProviders[providerMatch].push(m);
                    }
                });

                // Populate cloudflare provider select
                const providerSelect = document.getElementById('cloudflare-provider-select');
                providerSelect.innerHTML = '';
                const noneOption = document.createElement('option');
                noneOption.value = '';
                noneOption.textContent = '(Choose provider)';
                providerSelect.appendChild(noneOption);
                Object.keys(cloudflareProviders).forEach(p => {
                    const o = document.createElement('option');
                    o.value = p;
                    o.textContent = p;
                    providerSelect.appendChild(o);
                });

                // If there's at least one provider, preselect the first
                if (!providerSelect.value && providerSelect.options.length > 1) providerSelect.selectedIndex = 1;
                onCloudflareProviderChange();
                updateModelSelectors();
            } catch (err) {
                console.log('Models endpoint not available yet:', err);
            }
        }

        // Load models via /v1/models using a provided API key (used for OpenAI/Gemini when user supplies their key)
        async function loadModelsWithAuth(apiKey) {
            if (!apiKey) return;
            try {
                const res = await fetch('/v1/models', {
                    headers: {
                        'Authorization': 'Bearer ' + apiKey
                    }
                });
                if (!res.ok) {
                    console.warn('Authenticated /v1/models returned', res.status);
                    return;
                }
                const data = await res.json();
                const models = data.data || data.models || [];

                // Heuristics: split models into OpenAI-like and Gemini-like sets
                const openaiList = [];
                const geminiList = [];
                models.forEach(m => {
                    const id = (m.id || m.name || '').toLowerCase();
                    const owner = (m.owner || '').toLowerCase();
                    if (id.includes('gpt') || owner.includes('openai') || id.startsWith('text-') || id.startsWith('oai-')) {
                        openaiList.push(m);
                    } else if (id.includes('gemini') || owner.includes('google') || owner.includes('google-research')) {
                        geminiList.push(m);
                    } else {
                        // fallback: if ambiguous, add to both
                        openaiList.push(m);
                        geminiList.push(m);
                    }
                });

                // Populate UI selects
                const openaiSelect = document.getElementById('openai-model-select');
                const geminiSelect = document.getElementById('gemini-model-select');

                openaiSelect.innerHTML = '';
                geminiSelect.innerHTML = '';

                openaiList.forEach(m => {
                    const o = document.createElement('option');
                    o.value = m.id || m.name;
                    o.textContent = m.id || m.name;
                    openaiSelect.appendChild(o);
                });

                geminiList.forEach(m => {
                    const o = document.createElement('option');
                    o.value = m.id || m.name;
                    o.textContent = m.id || m.name;
                    geminiSelect.appendChild(o);
                });

                // If current AI service matches, update chat model choices
                updateModelSelectors();
            } catch (err) {
                console.error('Error loading models with auth:', err);
            }
        }

        // When user picks a cloudflare provider, populate provider-specific models
        function onCloudflareProviderChange() {
            const provider = document.getElementById('cloudflare-provider-select').value;
            const modelSelect = document.getElementById('cloudflare-model-select');
            modelSelect.innerHTML = '';
            if (!provider) return;
            const list = cloudflareProviders[provider] || [];
            list.forEach(m => {
                const o = document.createElement('option');
                o.value = m.id || m.name;
                o.textContent = m.id || m.name;
                modelSelect.appendChild(o);
            });
            updateModelSelectors();
        }

        // When AI service changes, show/hide controls and update chat model selector
        function onAIServiceChange() {
            const svc = document.getElementById('ai-service').value;
            document.getElementById('openai-controls').style.display = svc === 'openai' ? 'block' : 'none';
            document.getElementById('gemini-controls').style.display = svc === 'gemini' ? 'block' : 'none';
            document.getElementById('cloudflare-controls').style.display = svc === 'cloudflare' ? 'block' : 'none';
            document.getElementById('cloudflare-model-controls').style.display = svc === 'cloudflare' ? 'block' : 'none';

            // If user selected OpenAI or Gemini but we don't yet have their models loaded, attempt to load using global key
            const globalKey = document.getElementById('global-api-key').value;
            const chatKey = document.getElementById('chat-api-key').value;
            if ((svc === 'openai' || svc === 'gemini') && (globalKey || chatKey)) {
                loadModelsWithAuth(globalKey || chatKey);
            }

            updateModelSelectors();
        }

        // Map UI model controls into the single chat-model selector used in the chat UI
        function updateModelSelectors() {
            const svc = document.getElementById('ai-service').value;
            const chatModelSelect = document.getElementById('chat-model');
            chatModelSelect.innerHTML = '';

            if (svc === 'cloudflare') {
                // prefer currently selected cloudflare-model-select options
                const cfSelect = document.getElementById('cloudflare-model-select');
                if (cfSelect && cfSelect.options.length) {
                    Array.from(cfSelect.options).forEach(opt => {
                        const o = document.createElement('option');
                        o.value = opt.value;
                        o.textContent = opt.textContent;
                        chatModelSelect.appendChild(o);
                    });
                } else {
                    // fallback: include core availableModels
                    availableModels.forEach(m => {
                        const o = document.createElement('option');
                        o.value = m.id || m.name;
                        o.textContent = m.id || m.name;
                        chatModelSelect.appendChild(o);
                    });
                }
            } else if (svc === 'openai') {
                const openaiSelect = document.getElementById('openai-model-select');
                if (openaiSelect && openaiSelect.options.length) {
                    Array.from(openaiSelect.options).forEach(opt => chatModelSelect.appendChild(opt.cloneNode(true)));
                }
            } else if (svc === 'gemini') {
                const geminiSelect = document.getElementById('gemini-model-select');
                if (geminiSelect && geminiSelect.options.length) {
                    Array.from(geminiSelect.options).forEach(opt => chatModelSelect.appendChild(opt.cloneNode(true)));
                }
            }

            // If still empty, populate some sensible fallback options
            if (!chatModelSelect.options.length) {
                ['gpt-4', 'gpt-4o', 'gpt-3.5-turbo'].forEach(id => {
                    const o = document.createElement('option'); o.value = id; o.textContent = id; chatModelSelect.appendChild(o);
                });
            }
        }

        // Test connection button: attempt to call /v1/models with provided key
        async function testConnection() {
            const key = document.getElementById('global-api-key').value;
            if (!key) {
                alert('Enter your API key first');
                return;
            }
            try {
                const res = await fetch('/v1/models', { headers: { 'Authorization': 'Bearer ' + key } });
                const statusIndicator = document.getElementById('connection-status');
                const statusText = document.getElementById('connection-text');
                if (res.ok) {
                    statusIndicator.classList.remove('disconnected');
                    statusIndicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                    await loadModelsWithAuth(key);
                } else {
                    statusIndicator.classList.remove('connected');
                    statusIndicator.classList.add('disconnected');
                    statusText.textContent = 'Not Connected (' + res.status + ')';
                }
            } catch (err) {
                console.error('Connection test error', err);
                alert('Connection test failed: ' + err.message);
            }
        }

        function clearApiKey() {
            document.getElementById('global-api-key').value = '';
            document.getElementById('connection-text').textContent = 'Not Connected';
            document.getElementById('connection-status').classList.remove('connected');
            document.getElementById('connection-status').classList.add('disconnected');
        }

        function onChatApiKeyChange() {
            // If user enters a chat-specific key, attempt to load OpenAI/Gemini models using it
            const key = document.getElementById('chat-api-key').value;
            if (key) loadModelsWithAuth(key);
        }

        function handleChatKeyPress(e) {
            if ((e.key === 'Enter' && !e.shiftKey)) {
                e.preventDefault();
                sendChatMessage();
            }
        }

        function clearChat() {
            chatHistory = [];
            const container = document.getElementById('chat-messages');
            container.innerHTML = '';
        }

        // Robust streaming-aware chat sender
        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const userText = input.value.trim();
            if (!userText) return;

            const chatKey = document.getElementById('chat-api-key').value || document.getElementById('global-api-key').value;
            const aiService = document.getElementById('ai-service').value;
            const streamEnabled = document.getElementById('stream-chat').checked;

            // Determine model selection according to service
            let model = document.getElementById('chat-model').value;
            if (aiService === 'cloudflare') {
                // if chat-model empty, fallback to cloudflare-model-select
                model = model || document.getElementById('cloudflare-model-select').value;
            }

            // Append user message to UI
            const container = document.getElementById('chat-messages');
            const userMsg = document.createElement('div');
            userMsg.className = 'message user';
            userMsg.innerHTML = '<div class="role">User</div><div>' + escapeHtml(userText) + '</div>';
            container.appendChild(userMsg);
            container.scrollTop = container.scrollHeight;
            input.value = '';

            // Prepare request body for chat completions (OpenAI-style)
            const body = {
                model: model,
                messages: [
                    ...chatHistory,
                    { role: 'user', content: userText }
                ],
                stream: streamEnabled
            };

            const headers = { 'Content-Type': 'application/json' };
            if (chatKey) headers['Authorization'] = 'Bearer ' + chatKey;

            try {
                const res = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(body)
                });

                if (!res.ok) {
                    const errText = await res.text();
                    const errEl = document.createElement('div');
                    errEl.className = 'alert error';
                    errEl.textContent = 'Error: ' + res.status + ' - ' + errText;
                    container.appendChild(errEl);
                    container.scrollTop = container.scrollHeight;
                    return;
                }

                if (streamEnabled && res.body) {
                    // Create assistant message block that we will stream into
                    const assistantMsg = document.createElement('div');
                    assistantMsg.className = 'message assistant';
                    assistantMsg.innerHTML = '<div class="role">Assistant</div><div class="streaming-content"></div>';
                    container.appendChild(assistantMsg);
                    container.scrollTop = container.scrollHeight;

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    let finalText = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });

                        // Split on newlines to handle 'data: {...}' chunks
                        const lines = buffer.split(/\n/);
                        // Keep last partial line in buffer
                        buffer = lines.pop() || '';

                        for (let line of lines) {
                            line = line.trim();
                            if (!line) continue;
                            // common SSE style: 'data: {...}' or 'data: [DONE]'
                            if (line.startsWith('data:')) {
                                const payload = line.replace(/^data:\s*/, '');
                                if (payload === '[DONE]') {
                                    // stream finished
                                    buffer = '';
                                    break;
                                }
                                try {
                                    const parsed = JSON.parse(payload);
                                    const delta = (parsed.choices && parsed.choices[0]) || parsed;
                                    // Try several possible fields for content
                                    const part = (delta.delta && delta.delta.content) || (delta.delta && delta.delta.text) || delta.text || (delta.message && delta.message.content) || delta.choices?.[0]?.text;
                                    if (part) {
                                        finalText += part;
                                        assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                        container.scrollTop = container.scrollHeight;
                                    }
                                } catch (e) {
                                    // not JSON, append raw
                                    finalText += payload + '\n';
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                }
                            } else {
                                // fallback: treat line as raw JSON or plain text
                                try {
                                    const parsed = JSON.parse(line);
                                    const text = parsed.choices?.[0]?.delta?.content || parsed.choices?.[0]?.text || parsed.message?.content || '';
                                    finalText += text;
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                } catch (e) {
                                    finalText += line + '\n';
                                    assistantMsg.querySelector('.streaming-content').innerHTML = escapeHtml(finalText);
                                }
                            }
                        }
                    }

                    // Finalize message
                    chatHistory.push({ role: 'user', content: userText });
                    chatHistory.push({ role: 'assistant', content: finalText });
                } else {
                    // Non-streaming response: parse JSON normally
                    const json = await res.json();
                    const text = extractTextFromResponseObject(json);
                    const assistantMsg = document.createElement('div');
                    assistantMsg.className = 'message assistant';
                    assistantMsg.innerHTML = '<div class="role">Assistant</div><div>' + escapeHtml(text) + '</div>';
                    container.appendChild(assistantMsg);
                    container.scrollTop = container.scrollHeight;

                    chatHistory.push({ role: 'user', content: userText });
                    chatHistory.push({ role: 'assistant', content: text });
                }
            } catch (err) {
                console.error('Chat request failed', err);
                const errEl = document.createElement('div');
                errEl.className = 'alert error';
                errEl.textContent = 'Request failed: ' + err.message;
                container.appendChild(errEl);
                container.scrollTop = container.scrollHeight;
            }
        }

        // Try to extract assistant text from typical OpenAI/Gemini /v1/chat/completions JSON
        function extractTextFromResponseObject(obj) {
            try {
                if (!obj) return '';
                if (obj.choices && obj.choices[0]) {
                    const choice = obj.choices[0];
                    if (choice.message && choice.message.content) return choice.message.content;
                    if (choice.text) return choice.text;
                    if (choice.delta && (choice.delta.content || choice.delta.text)) return choice.delta.content || choice.delta.text;
                }
                if (obj.output && Array.isArray(obj.output)) {
                    // Gemini-style
                    return obj.output.map(o => o.content?.map(c => c.text).join('') || '').join('\n');
                }
                return JSON.stringify(obj);
            } catch (e) {
                return '';
            }
        }

        // Endpoint selector for tester panel (existing UI hook)
        function selectEndpoint(name) {
            currentEndpoint = name;
            const holder = document.getElementById('endpoint-form');
            const responseArea = document.getElementById('endpoint-response');
            document.getElementById('endpoint-title').textContent = 'Test: ' + name;
            responseArea.innerHTML = '';
            holder.innerHTML = '';

            if (name === 'models') {
                holder.innerHTML = '<div class="form-group full-width"><label>API Key (optional)</label><input id="test-models-key" placeholder="Bearer key for provider-specific models"></div><button class="btn" onclick="runTestModels()">Run</button>';
            } else if (name === 'chat') {
                holder.innerHTML = '<div class="form-group"><label>API Key (optional)</label><input id="test-chat-key" placeholder="Bearer key"></div><div class="form-group full-width"><label>Model</label><input id="test-chat-model" placeholder="gpt-4"></div><div class="form-group full-width"><label>Messages (JSON array)</label><textarea id="test-chat-messages">[ { "role": "user", "content": "Hello" } ]</textarea></div><button class="btn" onclick="runTestChat()">Run</button>';
            } else if (name === 'completions') {
                holder.innerHTML = '<div class="form-group"><label>API Key (optional)</label><input id="test-comp-key" placeholder="Bearer key"></div><div class="form-group full-width"><label>Model</label><input id="test-comp-model" placeholder="gpt-4"></div><div class="form-group full-width"><label>Prompt</label><textarea id="test-comp-prompt">Hello</textarea></div><button class="btn" onclick="runTestCompletions()">Run</button>';
            }
            document.getElementById('endpoint-tester').style.display = 'block';
        }

        async function runTestModels() {
            const key = document.getElementById('test-models-key').value;
            const headers = key ? { 'Authorization': 'Bearer ' + key } : {};
            const res = await fetch('/v1/models', { headers });
            const text = await res.text();
            document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
        }

        async function runTestChat() {
            try {
                const key = document.getElementById('test-chat-key').value;
                const model = document.getElementById('test-chat-model').value || 'gpt-4';
                const messages = JSON.parse(document.getElementById('test-chat-messages').value || '[]');
                const headers = { 'Content-Type': 'application/json' };
                if (key) headers['Authorization'] = 'Bearer ' + key;
                const res = await fetch('/v1/chat/completions', { method: 'POST', headers, body: JSON.stringify({ model, messages }) });
                const text = await res.text();
                document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
            } catch (e) {
                document.getElementById('endpoint-response').innerHTML = '<div class="alert error">' + escapeHtml(e.message) + '</div>';
            }
        }

        async function runTestCompletions() {
            try {
                const key = document.getElementById('test-comp-key').value;
                const model = document.getElementById('test-comp-model').value || 'gpt-4';
                const prompt = document.getElementById('test-comp-prompt').value || '';
                const headers = { 'Content-Type': 'application/json' };
                if (key) headers['Authorization'] = 'Bearer ' + key;
                const res = await fetch('/v1/completions', { method: 'POST', headers, body: JSON.stringify({ model, prompt }) });
                const text = await res.text();
                document.getElementById('endpoint-response').innerHTML = '<pre class="json-viewer">' + escapeHtml(text) + '</pre>';
            } catch (e) {
                document.getElementById('endpoint-response').innerHTML = '<div class="alert error">' + escapeHtml(e.message) + '</div>';
            }
        }

        // expose a couple helpers to global scope for inline onclick usage
        window.selectEndpoint = selectEndpoint;
        window.copyToClipboard = copyToClipboard;
        window.testConnection = testConnection;
        window.clearApiKey = clearApiKey;
        window.runTestModels = runTestModels;
        window.runTestChat = runTestChat;
        window.runTestCompletions = runTestCompletions;
        window.sendChatMessage = sendChatMessage;
        window.showSection = showSection;
        window.clearChat = clearChat;
    </script>
</body>

</html>